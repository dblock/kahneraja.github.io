---
layout: post
title: MY TOP 10 TDD PAYOFFS
published: True
feature: 

---

*   [The Three Rules off TDD](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd)

These payoffs rely on the assumption that I’ve adhered to the 3 laws of tdd.

<table>

<thead>

<tr>

<th>Law</th>

<th>Description</th>

</tr>

</thead>

<tbody>

<tr>

<td>1. Start</td>

<td>You must start by writing the test and making it fail.</td>

</tr>

<tr>

<td>2. Minimal</td>

<td>You must write the minimal amount of code to pass your failing unit test.</td>

</tr>

<tr>

<td>3. Closure</td>

<td>You must stop when the test has passed.</td>

</tr>

</tbody>

</table>

Here’s a quick list of my top 10 TDD Payoffs.

<table>

<thead>

<tr>

<th>TDD Payoff</th>

<th>Notes</th>

</tr>

</thead>

<tbody>

<tr>

<td>Courage & Change</td>

<td>I can make changes without having to keep track of every step of progress I’ve previously made.</td>

</tr>

<tr>

<td>Continuity & Flow</td>

<td>When I’m working off a descriptive unit test I know where I’m at. I can see from the trail of unit tests what I’ve been focused on recently.I can deal with distractions without getting stressed. I don’t need to juggle my work.</td>

</tr>

<tr>

<td>Design</td>

<td>Writing unit tests affects the way I write production code. It affects the design of the classes, functions, data structures and properties I create. I encourages me to create easier to read more decoupled solutions.</td>

</tr>

<tr>

<td>Testing First & Iteration</td>

<td>Writing my tests first means they actually get done. When I write the tests after I’m done writing the code I tend to only write the primary cases. Working on one unit test at a time means I don’t have to write a large collection of tests after a large dump of code. Iterating through a small test by implementing a small amount of code sounds slow but it means never getting lost in spaghetti dependency.</td>

</tr>

<tr>

<td>Communication & Talking</td>

<td>When I talk to colleagues it’s much easier to describe what I’m working on if I can show them a failing unit test</td>

</tr>

<tr>

<td>Workflow & Relaxation</td>

<td>Finding an organised way of thinking about my work makes it easier to estimate and express my progress. Using the red, green, refactor loop is an relaxing workflow.</td>

</tr>

<tr>

<td>Collaboration & Source control</td>

<td>I find it easier to share the workload if each of my colleagues are working on various unit tests. It’s an easy way to prevent a road block / collision.</td>

</tr>

<tr>

<td>Speed & Reduced repetition</td>

<td>TDD is fast. It’s faster that no using tdd. Running unit tests automatically, rather than running firing up the application and testing it manually, makes me infinitely more efficient.</td>

</tr>

<tr>

<td>Book keeping</td>

<td>Knowing that something works from two angles is awesome. Double entry book keeping. It’s a universal financial account practice that works well. It’s consider appropriate due diligence.</td>

</tr>

<tr>

<td>QA & Professionalism</td>

<td>When QA find an issue I write a unit test that matches their concern and then I fix it. I can track my progress inline with their efforts.</td>

</tr>

</tbody>

</table>

    "I know of no better way than to ensure my code works than to practice the 3 laws of test driven development." -Uncle Bob.